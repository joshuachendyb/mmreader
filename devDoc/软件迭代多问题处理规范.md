# 软件迭代多问题处理规范

**文档创建时间**: 2026-02-04 04:20:00
**更新时间**: 2026-02-04 04:30:00
**适用场景**: 复杂问题修复、功能迭代、Bug定位
**核心原则**: 逐个击破，验证后再下一步

---

## 一、问题分析原则

### 1.1 问题分类方法

| 问题类型 | 说明 | 分析方法 |
|---------|------|---------|
| **独立问题** | 问题之间互不影响 | 分别定位，分别修复 |
| **关联问题** | 问题之间有因果关系 | 先因后果，顺序修复 |
| **相似问题** | 问题表现类似但原因不同 | 对比分析，区分对待 |

### 1.2 分析步骤

```
步骤1: 收集所有错误信息
         ↓
步骤2: 按错误类型分类
         ↓
步骤3: 找出问题的共性和差异
         ↓
步骤4: 制定修复优先级
         ↓
步骤5: 逐个修复并验证
```

### 1.3 分析工具

| 工具 | 用途 |
|-----|------|
| 错误码 | 快速定位问题类型 |
| 代码对比 | 找出差异点 |
| 测试验证 | 确认问题是否存在 |

---

## 二、区分"需要修复"与"合法代码"

### 2.1 区分原则

| 判断标准 | 需要修复 | 合法代码 |
|---------|---------|---------|
| 语法正确性 | 语法解析报错 | 语法正确，正常运行 |
| 符号位置 | 特殊符号在不合法位置 | 特殊符号在合法位置 |
| 上下文 | 影响功能或渲染 | 不影响功能或渲染 |

### 2.2 验证方法

**方法1: 语法测试**
```javascript
// 测试代码是否报错
try {
    await parse(code);
    // 不报错 → 合法代码
} catch (error) {
    // 报错 → 需要修复
}
```

**方法2: 对比分析**
```
// 问题代码（需要修复）
Node["内容 | 内容"]  // 有特定符号在不合法位置

// 合法代码（不应修复）
Node["普通文本"]  // 内容是普通文本
```

### 2.3 判断标准

```
需要修复的代码特征:
├── 包含特定符号（| ( ) 等）
├── 符号位置不合法（导致解析报错）
└── 影响正常功能

合法代码特征:
├── 不包含问题符号
└── 符号位置不影响解析
```

---

## 三、修复规则设计

### 3.1 规则设计原则

```
精确修复 checklist:
□ 只修复真正导致错误的模式
□ 避免"一刀切"的全局替换
□ 明确修复条件（有/无特定符号）
□ 保护合法代码不被误伤
```

### 3.2 规则表达方式

| 规则类型 | 表达方式 | 作用 |
|---------|---------|------|
| 条件匹配 | `/[条件]/g` | 只匹配符合条件的代码 |
| 分组捕获 | `( )` | 提取需要处理的内容 |
| 替换规则 | `replacement` | 定义修复后的内容 |

### 3.3 规则验证

```
验证步骤:
1. 准备测试用例（需要修复 + 不需要修复）
2. 应用修复规则
3. 验证结果
   - 需要修复的 → 已被修改
   - 不需要修复的 → 保持原样
```

---

## 四、逐个修复流程

### 4.1 修复优先级

| 优先级 | 问题类型 | 处理方式 |
|-------|---------|---------|
| P0 | 阻塞性问题 | 立即修复 |
| P1 | 核心功能问题 | 优先修复 |
| P2 | 边缘问题 | 按需修复 |
| P3 | 优化建议 | 排期修复 |

### 4.2 修复步骤

```
第1步: 备份当前代码
         ↓
第2步: 应用修复规则
         ↓
第3步: 构建测试
         ↓
第4步: 验证结果
         ↓
第5步: 修复下一个问题
         ↓
...重复直到全部解决
```

### 4.3 修复操作

```bash
# 1. 备份
mkdir -p backup/v{版本号}_before_fix_{时间戳}
cp {目标文件} backup/v{版本号}_before_fix_{时间戳}/

# 2. 修改代码
# ...编辑文件...

# 3. 构建测试
{构建命令}

# 4. 验证结果
# 运行应用，测试功能
```

---

## 五、验证标准

### 5.1 验证项目

| 验证项 | 检查方法 |
|-------|---------|
| 问题已修复 | 运行原问题代码，无报错 |
| 无新问题 | 检查其他功能是否正常 |
| 无回归 | 验证已修复的问题不复发 |

### 5.2 验证流程

```
验证步骤1: 测试原问题代码
         ↓
验证步骤2: 测试相关功能
         ↓
验证步骤3: 测试边缘场景
         ↓
验证步骤4: 确认修复完成
```

---

## 六、常见问题与避免

### 6.1 错误做法

| 错误做法 | 后果 | 正确做法 |
|---------|------|---------|
| 一次性修复所有问题 | 无法定位哪个修复有效 | 逐个修复，验证后再下一步 |
| 不区分问题类型 | 过度修复或遗漏 | 分类分析，区别对待 |
| 规则设计太激进 | 误伤合法代码 | 精确匹配，边界保护 |
| 不验证就修复 | 修复无效或引入新问题 | 每步必验证 |

### 6.2 正确流程

```
问题发现
    ↓
收集信息（错误码、错误位置、复现条件）
    ↓
分类分析（需要修复/合法代码）
    ↓
设计修复规则（精确、边界保护）
    ↓
逐个修复（备份→修复→验证）
    ↓
全部解决
```

---

## 七、总结

### 核心原则

```
1. 问题要分类
   - 区分需要修复和合法代码
   - 分类处理，区别对待

2. 修复要逐个
   - 每次只修复一个问题
   - 验证后再进行下一步

3. 规则要精确
   - 明确修复条件
   - 避免一刀切

4. 每步必验证
   - 验证问题已修复
   - 验证无新问题
   - 验证无回归
```

### 口诀

```
问题发现先分类
需要修复合法分
逐个击破不贪多
修复一个测一个
规则设计要精确
边界保护不能少
每步验证不可少
全部解决才收工
```

---

**文档更新时间**: 2026-02-04 04:30:00
**创建人**: OpenCode AI Assistant
**版本**: 1.1
